## 一.内存管理

一般的语言中，内存的生命周期基本为如下三个步骤。
1.	分配你所需要的内存
2.	使用分配到的内存
3.	不需要时将其释放

在 `JavaScript` 中，`1`和`3` 是自动完成的。

### 内存分配
在以下情况中，`JavaScript` 会自动分配内存：

1.	定义变量时，会分配内存
2.	使用 `new`关键字时，创建的空对象会被分配内存
3.	函数调用中，参数和返回值的创建会分配内存

### 内存回收
1.	`JavaScript` 有“垃圾回收器” 专门用来管理内存的使用。
2.	引用：一个对象如果有访问另一个对象的权限（隐式或者显式），叫做一个对象引用另一个对象。
	
	> 一个Javascript对象具有对它原型的引用（隐式引用）和对它属性的引用（显式引用）。

#### 引用计数算法
1.	在内存内部，每个值有一个计数器进行计数。当值被引用时，计数器的值加一，当引用变量发生变化时，计数器的值减一。
2.	此算法把“对象是否不再需要”简化定义为“对象有没有其他对象引用到它”。如果没有引用指向该对象（零引用），对象将被垃圾回收机制回收。
	!> IE 6, 7 使用的引用计数算法，常常造成对象被循环引用时内存发生泄漏。

```js
  var o = {};
  var o2 = {};
  o.a = o2; // o 引用 o2
  o2.a = o; // o2 引用 o
```

引用计数的模拟实现可参考 [ref-count.js](https://gitee.com/pikoyo/front-learn/tree/master/src/js/ref-count.js)

#### 标记-清除算法
1.	这个算法把“对象是否不再需要”简化定义为“对象是否可以获得”。
2.	这个算法假定设置一个叫做根（root）的对象（在Javascript里，根是全局对象）。垃圾回收器将定期从根开始，找所有从根开始引用的对象，然后找这些对象引用的对象……从根开始，垃圾回收器将找到所有可以获得的对象和收集所有不能获得的对象。
3.	常见的根：
	+	当前函数的局部变量和参数。
	+	嵌套调用时，当前调用链上所有函数的变量与参数。
	+	全局变量。

4.	优化建议：
	+	分代收集（`Generational collection`）—— 对象被分成两组：“新的”和“旧的”。许多对象出现，完成他们的工作并很快死去，他们可以很快被清理。那些长期存活的对象会变得“老旧”，而且被检查的频次也会减少。
	+	增量收集（`Incremental collection`）—— 如果有许多对象，并且我们试图一次遍历并标记整个对象集，则可能需要一些时间，并在执行过程中带来明显的延迟。所以引擎试图将垃圾收集工作分成几部分来做。然后将这几部分会逐一进行处理。这需要他们之间有额外的标记来追踪变化，但是这样会有许多微小的延迟而不是一个大的延迟。
	+	闲时收集（`Idle-time collection`）—— 垃圾收集器只会在 CPU 空闲时尝试运行，以减少可能对代码执行的影响。

## 参考资料
1.	垃圾回收——现代JavaScript教程：https://zh.javascript.info/garbage-collection
2.	内存管理——MDN：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Memory_Management
